name: Build

on: [push, pull_request]

jobs:
  build:
    if: github.repository == 'DreamPearl/qpid-proton'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macOS-latest]
        buildType: [RelWithDebInfo]
        include:
        - os: windows-latest
          cmake_extra: '-A x64 -DCMAKE_TOOLCHAIN_FILE=C:/vcpkg/scripts/buildsystems/vcpkg.cmake'
          cmake_generator: '-G "Visual Studio 16 2019"'
        - os: macOS-latest
          pkg_config_path: '/usr/local/opt/openssl@1.1/lib/pkgconfig'
          cmake_extra: '-DBUILD_RUBY=no -DTHREADERCISER=ON'
          ctest_extra: '--exclude-regex c-threaderciser'
    env:
      BuildType: ${{matrix.buildType}}
      BuildDir: ${{github.workspace}}/BLD
      InstallPrefix: ${{github.workspace}}/INSTALL
      PKG_CONFIG_PATH: ${{matrix.pkg_config_path}}
      VCPKG_DEFAULT_TRIPLET: x64-windows
      OTelDir: ${{github.workspace}}/opentelemetry-cpp
      OTelBuildDir: ${{github.workspace}}/opentelemetry-cpp/BLD
      OTelInstallPrefix: /usr
      CurlDir: ${{github.workspace}}/curl
      CurlBuildDir: ${{github.workspace}}/curl/BLD
      CurlInstallPrefix: /usr
    steps:
    - uses: actions/checkout@v2
    - name: Create Build and Install directories
      run: mkdir -p "${BuildDir}" "${InstallPrefix}"
      shell: bash

    # PROTON-2295 avoid using go 1.15.3 on macOS, which is broken
    - if: runner.os == 'macOS'
      name: Setup go (Mac OS)
      uses: actions/setup-go@v2
      with:
        go-version: '^1.15.4'

    - name: Setup python
      uses: actions/setup-python@v2
      with:
        python-version: 3.6
        architecture: x64
    - name: Install python dependencies
      run: |
        python -m pip install --upgrade pip
        python -m pip install setuptools wheel tox
    - name: Install Linux dependencies
      if: runner.os == 'Linux'
      run: |
        sudo apt install -y swig libpython3-dev libsasl2-dev libjsoncpp-dev
    - name: Install Windows dependencies
      if: runner.os == 'Windows'
      run: |
        choco install -y swig --version=4.0.1
        vcpkg install jsoncpp
        vcpkg integrate install
    - name: Install MacOS dependencies
      if: runner.os == 'macOS'
      run: |
        brew install libuv swig pkgconfig jsoncpp
    - name: Checkout curl repo (for jaeger)
      if: runner.os == 'Linux'
      uses: actions/checkout@v2
      with:
        repository: curl/curl
        path: ${{env.CurlDir}}
        submodules: recursive
    - name: Create Build directory for curl
      run: mkdir -p "${CurlBuildDir}"
      shell: bash
    - name: curl cmake configure
      if: runner.os == 'Linux'
      working-directory: ${{env.CurlBuildDir}}
      run: cmake "${{github.workspace}}/curl" "-DCMAKE_INSTALL_PREFIX=${CurlInstallPrefix}" "-DBUILD_SHARED_LIBS=ON" "-DCMAKE_POSITION_INDEPENDENT_CODE=ON" "-DBUILD_TESTING=OFF" "-DCMAKE_BUILD_TYPE=${BuildType}"
      shell: bash
    - name: curl cmake build/install
      if: runner.os == 'Linux'
      run: |
        cmake --build "${CurlBuildDir}" --target all
        sudo cmake --install "${CurlBuildDir}" --config ${BuildType}
      shell: bash
    - name: install thrift (for jaeger)
      if: runner.os == 'Linux'
      run: sudo ./ci/setup_thrift.sh
      shell: bash
    - name: Create directory for opentelemetry-cpp
      run: mkdir -p "${OTelDir}"
      shell: bash
    - name: Checkout opentelemetry-cpp repo
      if: runner.os == 'Linux'
      uses: actions/checkout@v2
      with:
        repository: open-telemetry/opentelemetry-cpp
        path: ${{env.OTelDir}}
        submodules: recursive
    - name: Create Build directory for opentelemetry-cpp
      if: runner.os == 'Linux'
      run: mkdir -p "${OTelBuildDir}"
      shell: bash
    - name: opentelemetry-cpp cmake configure
      if: runner.os == 'Linux'
      working-directory: ${{env.OTelBuildDir}}
      run: cmake "${{github.workspace}}/opentelemetry-cpp" "-DCMAKE_INSTALL_PREFIX=${OTelInstallPrefix}" "-DBUILD_SHARED_LIBS=ON" "-DCMAKE_POSITION_INDEPENDENT_CODE=ON" "-DBUILD_TESTING=OFF" "-DCMAKE_BUILD_TYPE=${BuildType}" "-DWITH_JAEGER=ON"
      shell: bash
    - name: opentelemetry-cpp cmake build/install
      if: runner.os == 'Linux'
      run: |
        cmake --build "${OTelBuildDir}" --target all
        sudo cmake --install "${OTelBuildDir}" --config ${BuildType}
      shell: bash
    - name: cmake configure
      working-directory: ${{env.BuildDir}}
      run: cmake "${{github.workspace}}" "-DCMAKE_BUILD_TYPE=${BuildType}" "-DCMAKE_INSTALL_PREFIX=${InstallPrefix}" ${{matrix.cmake_extra}} "-Dopentelemetry-cpp_DIR=${OTelInstallPrefix}/lib/cmake/opentelemetry-cpp"
      shell: bash
    - name: cmake build/install
      run: cmake --build "${BuildDir}" --config ${BuildType} -t install
      shell: bash
    - name: Upload Install
      uses: actions/upload-artifact@v2
      with:
        name: qpid_proton_pkg_${{matrix.os}}_${{matrix.buildType}}
        path: ${{env.InstallPrefix}}
    - name: Upload python packages
      uses: actions/upload-artifact@v2
      with:
        name: python-pkgs
        path: ${{env.BuildDir}}/python/pkgs
    - id: ctest
      name: ctest
      working-directory: ${{env.BuildDir}}
      run: ctest -C ${BuildType} -V -T Test --no-compress-output ${{matrix.ctest_extra}}
      shell: bash
    - name: Upload Test results
      if: always() && (steps.ctest.outcome == 'failure' || steps.ctest.outcome == 'success')
      uses: actions/upload-artifact@v2
      with:
        name: Test_Results_${{matrix.os}}_${{matrix.buildType}}
        path: ${{env.BuildDir}}/Testing/**/*.xml
    - name: Upload Python & C build directories on failure
      uses: actions/upload-artifact@v2
      if: failure()
      with:
        name: Debug-python-C-BLD_${{matrix.os}}_${{matrix.buildType}}
        path: |
          ${{env.BuildDir}}/c
          ${{env.BuildDir}}/python
    - name: Environment (Linux/Windows)
      if: always() && runner.os != 'macOS'
      run: env -0 | sort -z | tr '\0' '\n'
      shell: bash
    - name: Environment (macOS)
      if: always() && runner.os == 'macOS'
      run: env | sort
      shell: bash
